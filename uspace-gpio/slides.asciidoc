= Linux Userspace GPIO Access

== GPIO

=== Introduction

These are the processor pins which can be used for general purpose
digital input and output.

 * General Purpose Input Output(GPIO) are single pin IO, represents
   voltage signal as binary logic level `high` and `low`.

 * GPIO `high` maps to voltage closer to VCC and `low` maps to voltage
   closer to ground.

 * Typical `high` state is considered as logical `1` and low as `0`.

 * It can operate in both the directions, as an input to sample the
   logic level or as an output to drive any logic level

 * Their direction as input or output can be chosen.

 * The pin status can be read or modified from software.

[role="two-column"]
=== GPIO Grouping 

[role="left"]
 * The GPIOs are organised as PORTS or BANKS where a set of GPIOs are
   combined together for convenience

 * In a 32 bit processors, the ports may have 32 GPIO pins together in
   a port.

 * GPIOs pins are referred as particular pin in a particular port,
   Ex:P2_3 - `pin 3 in port 2`

[role="right"]
image::figures/ports.png[]

=== GPIO Numbering

 * The processor pin has to be configured as GPIO in the pinmux
   configuration.

 * Vybrid VF510 has PORT0 to PORT5 

 * The pin sequence number can be generated as 

----
Pin Seq No = PORT * 32 + PIN

For pin `P2_3`,

  2 * 32 + 3 = 67 
----

=== ZKit GPIO Mappings

[options="header"]
|====================================
| Device | Port Pin | Pin Sequence No
| LED1   | P2_6     | GPIO70
| LED2   | P2_0     | GPIO64
| LED3   | P2_1     | GPIO65
| KEY1   | P2_5     | GPIO69
| KEY2   | P2_3     | GPIO67
|====================================

=== GPIO Applications

* Used to control LEDs and sense keys.

* Used to controll 7Segment, Stepper Motor etc.,

* Used for 7segment Arrays, LED Matrices & Matric keypads

* Used for interrupts signalling

[role="two-column"]
=== GPIO in Linux

[role="left"]
* In Linux the gpio interfaces can be accessed from userspace
  application through sysfs.

* The access to sysfs goes to generic GPIO driver called `gpiolib` which
  inturn calls the processor specific GPIO driver.

[role="right"]
image::figures/layer.png[]

== SYSFS GPIO

[role="two-column"]
=== GPIO Files in Sysfs

[role="left"]
* Inside `sysfs` in path '/sys/class/gpio` we have files which allows
  to monitor and control the GPIO.

* For each GPIO a folder '/sys/class/gpio/gpio<no>' is created and it
  would have below files.

* the `direction` file allows to control direction of pin and `value`
  file would allow to access the pin state.


[role="right"]
----

/sys/class/gpio/
| -- gpio<no>
     | -- value
     ` -- direction 

----

== LEDs

[role="two-column"]
=== Led Circuitary

[role="left"]
* The LED's anode is connected to Vcc and LED's cathode is grounded
  through a 330 ohm resistor.

* A MOSFET is connected between the LED and the ground which acts as a
  switch.

* A voltage applied to the gate, makes the LED to ground so that it
  can glow.

* GPIO pin connected to the gate, can be used to switch on/off the
  LED.

[role="right"]
image::figures/leds.png[]

=== GPIO Access

The processor pin can be configured as output pin by setting '1' to
the GPIO direction file

.Example to set Port 2 and Pin 1 with `1`
----
$ echo out > /sys/class/gpio/gpio65/direction
----

 * When value is set to '1' through the value file, it can drive logic
   level high

.Example to set Port 2 and Pin 1 with `1`
----
$ echo 1 > /sys/class/gpio/gpio65/value
----

 * When bit value is set to '0' through GPIO Data registers, it can
   drive digital logic level low

=== LEDs in Output Mode Contd.

.Example to set Port 2 and Pin 1 with `1`
----
$ echo 1 > /sys/class/gpio/gpio65/value
----

=== LED Glow

[source,python]
----
include::led.py[]
----

=== LED Blinky

[source,python]
----
include::led-blink.py[]
----
 
== Keys

[role="two-column"]
=== Keys Circuitary

[role="left"]
* A key has two terminals, when pressed it mechanically connects the
  terminals.

* To detect whether a key is pressed/released or idle it has to be
  sensed.

* one terminal of key can be connected to GND other to the GPIO pin.

* The GPIO pin has been defaulted to high level, by a pull-up to VCC
  through a resistor.

* When the key is unpressed the GPIO stays high and when pressed it
  gets low.

[role="right"]
image::figures/keys.png[]

=== Key Polling

* Since the key press is asynchronous, it has to be polled
  continuously or periodically.

* Continuously polling for key may burn the CPU or would starve other
  processes, instead periodical polling can be used.

* Typical key stroke period by humans couldn't be less than few
  hundred millisecs.

* it's enough that we can poll for key press once in 100msec. 

=== Programming for Keys

.Key Sample Code
[source,python]
----
include::key.py[]
----

=== Key Debounce

* The switches or keys used are mechanical devices and when key is
  pressed or depressed they tend to vibrate creating noises until it
  settles down.

* This condition can be handled in hardware by adding a filter.

* It can also be handled in software by waiting for specific time from
  the event occurence till it settles down.

* This delay time is typically around few hundred millisecond and
  called debounce delay.

=== Programming with Key Debounce

.Key Debounce Sample Code
[source,python]
----
include::key-debounce.py[]
----

=== Error Handling

* Above example codes doesn't handle error conditions to keep the
  program simple to follow.

* A proper code needs to handle below given errors.

* General file access errors like file non existence and permission
  issues.

* If key is already exported then you cannot export it again.

* If a gpio file is not created, then you cannot the access the value
  and direction file.

* If the gpio pin usage is completed it can be unexported by righting
  to `unexport` file.
 
== GPIO Usage Models

=== Various GPIO Usage patterns

* Individual GPIOs for single LED & Key.

* Parallel GPIOs for 7Seg, Stepper Motor etc.,

* Multiplexed GPIOs for Multi Seven Segment Display, Matrix Keypad
  etc.,

* GPIOs can be coupled to with timer for timed signalling or to create
  pulse trains of various width.

* Can be used as an interrupt source from external devices.

* GPIOs as its name suggests, has countless possibility that using
  which we can build simple busses like I2C, 1 wire, SPI and complex
  Memory bus using bitbanging technique.

== References

=== Links

* http://slideplayer.com/slide/11129925/

* bhttps://developer.android.com/things/hardware/hardware-101.html

== Backup Slides

=== ZKit GPIO Mappings

* GPIO4    - PTD24 - P2_6 -  RGPIO[70] - LED1
* GPIO23   - PTD29 - P2_0  - RPGIO[64] - LED2
* GPIO24   - PTD30 - P2_1  - RGPIO[65] - LED3

* GPIO17   - PTD25 - P2_5  - RGPIO[69] - KEY1
* GPIO27   - PTD27 - P2_3  - RGPIO[67] - KEY2

